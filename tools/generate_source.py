#!/usr/bin/env python3

"""
Scripts to generate source-code files from the pcd.yaml file

The script is intended to be used by Earth System Model applications
to generate valid source code files to be used throughout the code.
The goal is to ensure that different parts of the project (and possibly
different projects) all agree on the numerical value of common
physical constants.

As of 12/2024, the script supports generting a C++ header or a F90 module.
"""

import sys
import pathlib
import argparse
import yaml

this_script_dir = pathlib.Path(__file__).parent

###############################################################################
def parse_command_line(args, description):
###############################################################################
    """
    Parse command line arguments
    """
    parser = argparse.ArgumentParser(
        usage=f"\n{pathlib.Path(args[0]).name} <ARGS> [--verbose]\n\n"
               "EXAMPLES\n\n"
               "   # Generate the Fortran90 module 'constants.F90' with all constants.\n"
               "   > {0} --lang f90 -f constants.F90\n"
               "   # Generate the C++ header 'constants.h' with only 'mathematics' constants\n"
               "   > {0} --lang cxx --groups mathematics -f constants.h\n",
        description=description)

    langs = ['cxx','f90']
    parser.add_argument('-l', '--lang',
                        help='Language for which to enerate.',
                        type=str, choices=langs, required=True)
    parser.add_argument('-g', '--groups',
                        help='Groups to include in the generated file (optional).'
                             'If not provided, include all groups', nargs='+')
    parser.add_argument('-f', '--filename',
                        help='Name of the generated output file',
                        type=str, required=True)

    return parser.parse_args(args[1:])

###############################################################################
def write_header(ofile,lang,version,institution):
###############################################################################
    """
    Write file header
    """
    repo = 'https://github.com/e3sm-project/PhysicalConstantsDictionary'
    if lang=='cxx':
        ofile.write('// WARNING! DO NOT EDIT THIS FILE!\n')
        ofile.write('// This file was generated automatically from pcd.yaml\n')
        ofile.write(f'// For more information, visit {repo}\n\n')
        ofile.write('#ifndef PHYSICAL_CONSTANTS_DICTIONARY_HPP\n')
        ofile.write('#define PHYSICAL_CONSTANTS_DICTIONARY_HPP\n\n')
        ofile.write('#include <string>\n\n')
        ofile.write('namespace pcd {\n\n')
        ofile.write(f'// pcd.yaml version and institution information\n')
        ofile.write(f'const std::string pcdversion = "{version}";\n')
        ofile.write(f'const std::string pcdinstitution = "{institution}";\n')
    elif lang=='f90':
        ofile.write('! WARNING! DO NOT EDIT THIS FILE!\n')
        ofile.write('! This file was generated automatically from pcd.yaml\n')
        ofile.write(f'! For more information, visit {repo}\n\n')
        ofile.write('module pcd\n')
        ofile.write('    implicit none\n\n')
        ofile.write('    !define double precision kind\n')
        ofile.write('    integer, parameter :: dp = selected_real_kind(12)\n\n')
        ofile.write('    ! pcd.yaml version and institution information\n')
        ofile.write(f'    character(len=*), parameter :: pcdversion = "{version}"\n')
        ofile.write(f'    character(len=*), parameter :: pcdinstitution = "{institution}"\n')
    else:
        raise RuntimeError(f'Missing implementation for language {lang}')

###############################################################################
def write_footer(ofile,lang):
###############################################################################
    """
    Write file footer
    """
    if lang=='cxx':
        ofile.write('\n} // namespace pcd \n')
        ofile.write('#endif // PHYSICAL_CONSTANTS_DICTIONARY\n')
    elif lang=='f90':
        ofile.write('\nend module pcd\n')
    else:
        raise RuntimeError(f'Missing implementation for language {lang}')

###############################################################################
def format_units(units_str):
###############################################################################
    """
    Format units string for display in comments.
    Convert 'none' to '[1]' for dimensionless constants.
    Convert space-separated notation to a more readable format.
    Examples:
      'm s-1' -> '[m/s]'
      'm3 kg-1 s-2' -> '[m3/(kg s-2)]'  # keeping complex forms readable
      'Pa' -> '[Pa]'
    """
    if units_str == 'none':
        return '[1]'
    
    # Split units by space
    parts = units_str.split()
    
    # Separate numerator and denominator
    numerator = []
    denominator = []
    
    for part in parts:
        if '-1' in part or '-2' in part or '-3' in part or '-4' in part:
            # This is a denominator term, remove the negative exponent for display
            # e.g., 's-1' -> 's', 's-2' -> 's2'
            if '-1' in part:
                denominator.append(part.replace('-1', ''))
            elif '-2' in part:
                denominator.append(part.replace('-2', '2'))
            elif '-3' in part:
                denominator.append(part.replace('-3', '3'))
            elif '-4' in part:
                denominator.append(part.replace('-4', '4'))
        else:
            numerator.append(part)
    
    # Build the formatted string
    if not denominator:
        # No denominator, just join numerator parts
        return f'[{" ".join(numerator)}]'
    elif not numerator:
        # Only denominator (like mol-1)
        return f'[1/{" ".join(denominator)}]'
    elif len(denominator) == 1 and len(numerator) == 1:
        # Simple case like 'm s-1' -> 'm/s'
        return f'[{numerator[0]}/{denominator[0]}]'
    elif len(denominator) == 1:
        # Multiple numerator, single denominator like 'W m-2' -> 'W/m2'
        return f'[{" ".join(numerator)}/{denominator[0]}]'
    else:
        # Complex case with multiple parts in denominator
        return f'[{" ".join(numerator)}/({" ".join(denominator)})]'

###############################################################################
def write_group(ofile,lang,gname,group):
###############################################################################
    """
    Write constants from a single group
    """
    if lang=='cxx':
        ofile.write(f'\n// {gname} constants\n')
    elif lang=='f90':
        ofile.write(f'\n    !{gname} constants\n')
    else:
        raise RuntimeError(f'Missing implementation for language {lang}')

    # First pass: calculate max line length for alignment
    max_line_len = 0
    lines_data = []
    for c in group['entries']:
        n = c['name']
        v = c['value']
        r = c['reference']
        u = c.get('units', 'none')  # Get units, default to 'none' if not present
        
        if lang=='cxx':
            line = f'constexpr double {n} = {v};'
        elif lang=='f90':
            line = f'    real(dp), parameter :: {n} = {v}_dp'
        else:
            raise RuntimeError(f'Missing implementation for language {lang}')
        
        max_line_len = max(max_line_len, len(line))
        lines_data.append((line, u, r))
    
    # Add some spacing (4 spaces) between code and comment
    padding = max_line_len + 4
    
    # Second pass: write lines with proper alignment
    for line, u, r in lines_data:
        units_formatted = format_units(u)
        if lang=='cxx':
            ofile.write(f'{line:<{padding}} // {units_formatted} {r}\n')
        elif lang=='f90':
            ofile.write(f'{line:<{padding}} ! {units_formatted} {r}\n')
        else:
            raise RuntimeError(f'Missing implementation for language {lang}')

###############################################################################
def generate_file(lang, groups, filename):
###############################################################################
    """
    Parse the pcd.yaml file, and dump to file the content of the requested groups
    """

    with open(this_script_dir.parent / "pcd.yaml", 'r', encoding="utf-8") as fd:
        constants_dict = yaml.safe_load(fd)['physical_constants_dictionary']

    # Extract version and institution information
    version = constants_dict.get('version_number', 'unknown')
    institution = constants_dict.get('institution', 'unknown')

    groups_in_file = {}
    for g in constants_dict['set']:
        if len(g.keys()) > 1:
            raise ValueError('Invalid formatting of pcd database.\n'
                             'Each entry of the "set" sequence should contain ONE dictionary')
        for k, v in g.items():
            groups_in_file[k] = v
    valid_groups = list(groups_in_file.keys())
    if groups is not None and any(item not in valid_groups for item in groups):
        raise ValueError(f"Invalid value for groups: {','.join(groups)}.\n"
                         f"Valid choices are {','.join(valid_groups)}")

    with open(filename, 'w', encoding="utf-8") as ofile:
        # Header
        write_header(ofile,lang,version,institution)

        # Content, by group
        for gname,group in groups_in_file.items():
            if groups is None or gname in groups:
                write_group(ofile,lang,gname,group)

        # Footer
        write_footer (ofile,lang)


###############################################################################
def _main_func(description):
###############################################################################
    generate_file(**vars(parse_command_line(sys.argv, description)))
    sys.exit(0)

###############################################################################

if __name__ == "__main__":
    _main_func(__doc__)
